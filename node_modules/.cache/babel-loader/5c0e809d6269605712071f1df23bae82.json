{"ast":null,"code":"var _classCallCheck = require(\"E:\\\\-Web.IO-Reddit-Clone\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"E:\\\\-Web.IO-Reddit-Clone\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nvar request = require('request');\n\nvar url = require('url');\n\nvar Promise = require('bluebird'); // URLS\n// ------\n\n\nvar ACCESS_TOKEN_URL = \"https://www.reddit.com/api/v1/access_token\";\nvar REGULAR_REDDIT_URL = \"https://oauth.reddit.com\";\n\nmodule.exports = function (options) {\n  var API =\n  /*#__PURE__*/\n  function () {\n    \"use strict\";\n\n    function API(options) {\n      _classCallCheck(this, API);\n\n      this.token_expiration = 0;\n      this.token = null;\n      this.username = options.username;\n      this.password = options.password;\n      this.app_id = options.app_id;\n      this.api_secret = options.api_secret;\n      this.user_agent = options.user_agent; // Retry on wait\n      // If this parameter is present, then if the call errors out due to a \"you are doing this too much, try again in: x seconds\" error\n      // this will automatically hold the application (timeout) until the wait time has finished, and then retries. Only retries once.\n\n      this.retry_on_wait = false;\n\n      if (options.retry_on_wait) {\n        this.retry_on_wait = true;\n      } // Retry on reddit server error\n      // If this parameter is present, then the server will retry on a reddit server error. You can also specify the retry wait duration.\n\n\n      this.retry_on_server_error = 0;\n      this.retry_delay = 5; // Default 5sec retry delay\n\n      if (options.retry_on_server_error) {\n        this.retry_on_server_error = options.retry_on_server_error;\n\n        if (options.retry_delay) {\n          this.retry_delay = options.retry_delay;\n        }\n      } // If logs are enabled, default to true.\n\n\n      this.logs = false;\n\n      if (options.logs) {\n        this.logs = options.logs;\n      }\n    }\n\n    _createClass(API, [{\n      key: \"_logHelper\",\n      value: function _logHelper(str) {\n        if (this.logs) {\n          console.log(str);\n        }\n      }\n    }, {\n      key: \"_parseBodyHelper\",\n      value: function _parseBodyHelper(body_json) {\n        var self = this;\n        var body;\n\n        if (typeof body_json === \"string\") {\n          try {\n            body = JSON.parse(body_json);\n          } catch (e) {\n            self._logHelper(\"Error parsing JSON body: \" + e + \" just returning body.\");\n\n            body = body_json;\n          }\n        } else {\n          body = body_json;\n        }\n\n        return body;\n      }\n    }, {\n      key: \"get_token\",\n      value: function get_token() {\n        return this._get_token_helper(true);\n      }\n    }, {\n      key: \"_get_token_server_error_looper\",\n      value: function _get_token_server_error_looper() {\n        var self = this;\n        return new Promise(function (super_resolve, super_reject) {\n          return Promise.mapSeries(new Array(self.retry_on_server_error + 1), function () {\n            return new Promise(function (res1, rej1) {\n              self._get_token_helper(false).then(function (result) {\n                if (result != undefined) {\n                  return super_resolve(result);\n                } else {\n                  return setTimeout(function () {\n                    return res1();\n                  }, self.retry_delay * 1000);\n                }\n              }).catch(function (err) {\n                return super_reject(err);\n              });\n            });\n          });\n        });\n      }\n    }, {\n      key: \"_get_token_helper\",\n      value: function _get_token_helper(handleErrors) {\n        var self = this;\n\n        if (Date.now() / 1000 <= self.token_expiration) {\n          return Promise.resolve(self.token);\n        }\n\n        return new Promise(function (resolve, reject) {\n          request.post({\n            url: ACCESS_TOKEN_URL,\n            form: {\n              \"grant_type\": \"password\",\n              \"username\": self.username,\n              \"password\": self.password\n            },\n            auth: {\n              \"user\": self.app_id,\n              \"pass\": self.api_secret\n            },\n            headers: {\n              \"User-Agent\": self.user_agent\n            }\n          }, function (err, res, body) {\n            if (err) {\n              return reject(\"Error getting token: \" + err);\n            } // The status\n\n\n            var status_class = Math.floor(res.statusCode / 100);\n\n            if (status_class == 2) {\n              // 200 Level so **quickly** return.\n              var token_info = self._parseBodyHelper(body);\n\n              self.token_expiration = Date.now() / 1000 + token_info.expires_in / 2;\n              self.token = token_info.token_type + \" \" + token_info.access_token;\n\n              if (token_info.token_type == undefined || token_info.access_token == undefined) {\n                self._logHelper(\"The token retrieved was undefined. The username which we couln't get a token for is: \" + self.username);\n              }\n\n              return resolve(self.token);\n            } else if (status_class == 4) {\n              // Most likely a 403 here\n              self._logHelper(\"Getting token has resulted in: \" + res.statusCode + \" here. This can originate from not giving this user access in your Reddit App Preferences. Can't obtain token.\");\n\n              return resolve(self.token);\n            } else if (status_class == 5) {\n              // 503 possibly, server error most likely. do some retries if specified.\n              if (self.retry_on_server_error > 0 && handleErrors) {\n                self._logHelper(\"Received server error when trying to get token, attempting \" + (self.retry_on_server_error + 1) + \" retries.\");\n\n                return self._get_token_server_error_looper().then(function (newToken) {\n                  self.token = newToken;\n                  return resolve(self.token);\n                }).catch(function (err) {\n                  return reject(err);\n                });\n              } else {\n                if (handleErrors) {\n                  self._logHelper(\"Getting token has resulted in: \" + res.statusCode + \" here. Try enabling retries on server errors to automatically retry on this error.\");\n                }\n\n                return resolve(undefined);\n              }\n            } else {\n              return resolve(self.token);\n            }\n          });\n        });\n      }\n    }, {\n      key: \"_make_request\",\n      value: function _make_request(token, endpoint, method, data, waitingRetryCount, retryOnServerErrorEnabled, retryOn403) {\n        var self = this;\n        return new Promise(function (resolve, reject) {\n          var request_options = {\n            url: endpoint,\n            method: method,\n            headers: {\n              \"Authorization\": token,\n              \"User-Agent\": self.user_agent\n            }\n          };\n\n          if (method == \"GET\") {\n            request_options.qs = data;\n          } else if (method == \"PATCH\" || method == \"PUT\" || method == \"DELETE\") {\n            request_options.body = data;\n            request_options.json = true;\n          } else if (method == \"POST\") {\n            request_options.form = data;\n          }\n\n          self._logHelper(\"Making \" + method + \" request to: \" + endpoint);\n\n          request(request_options, function (err, res, body_json) {\n            if (err) {\n              return reject(\"Error making request: \" + err);\n            } // dont parse if its already an object\n\n\n            var body = self._parseBodyHelper(body_json); // The status\n\n\n            var status_class = Math.floor(res.statusCode / 100);\n\n            self._logHelper(\"Have gotten a response with the following statusCode: \" + res.statusCode);\n\n            switch (status_class) {\n              case 1:\n                // Information\n                return resolve([res.statusCode, body]);\n\n              case 2:\n                // Success\n                if (body && body.json && body.json.ratelimit) {\n                  var retryingSec = body.json.ratelimit;\n\n                  if (retryingSec > 0 && self.retry_on_wait && waitingRetryCount == 0) {\n                    self._logHelper(\"Retrying [in \" + retryingSec + \" seconds] making request due to ratelimit.\");\n\n                    return setTimeout(function () {\n                      // Retry this now that the wait is complete.\n                      return self._make_request(token, endpoint, method, data, waitingRetryCount + 1, true, true).then(function (results) {\n                        return resolve(results);\n                      }).catch(function (err) {\n                        return reject(err);\n                      });\n                    }, retryingSec * 1000);\n                  } else {\n                    return reject(\"you are doing this too much, try again in: \" + body.json.ratelimit + \" seconds\");\n                  }\n                } else {\n                  return resolve([res.statusCode, body]);\n                }\n\n              case 3:\n                // Redirection\n                return resolve([res.statusCode, body]);\n\n              case 4:\n                // Client error\n                // If this is a 403 (Forbidden) usually means that the access token has expired, so get a new token and retry.\n                if (res.statusCode == 403 && retryOn403) {\n                  self._logHelper(\"Encountered 403, retrying after grabbing new token.\");\n\n                  return self.get_token().then(function (tkn) {\n                    return self._make_request(tkn, endpoint, method, data, waitingRetryCount, retryOnServerErrorEnabled, false).then(function (results) {\n                      return resolve(results);\n                    }).catch(function (err) {\n                      return reject(err);\n                    });\n                  }).catch(function (err) {\n                    return reject(err);\n                  });\n                } else if (res.statusCode == 403) {\n                  return reject(\"Received two 403's in a row. Not retrying again.\");\n                }\n\n                return resolve([res.statusCode, body]);\n\n              case 5:\n                // Server Error\n                if (self.retry_on_server_error > 0 && retryOnServerErrorEnabled) {\n                  return self._make_request_helper(token, endpoint, method, data).then(function (results) {\n                    return resolve(results);\n                  }).catch(function (err) {\n                    return reject(err);\n                  });\n                } else {\n                  return reject(\"server error has occured: \" + res.statusCode + \" and body: \" + body);\n                }\n\n              default:\n                return reject(\"Shouldn't have reached here. StatusCode: \" + res.statusCode + \" and Body: \" + body);\n            }\n          });\n        });\n      }\n    }, {\n      key: \"_make_request_helper\",\n      value: function _make_request_helper(token, endpoint, method, data) {\n        var self = this;\n        return new Promise(function (super_resolve, super_reject) {\n          return Promise.mapSeries(new Array(self.retry_on_server_error + 1), function () {\n            return new Promise(function (resolve, reject) {\n              self._make_request(token, endpoint, method, data, 0, false, true).then(function (results) {\n                return super_resolve(results);\n              }).catch(function (err) {\n                var errSplit = err.toString().split(\"server error\");\n\n                if (errSplit.length >= 2) {\n                  // Continue (aka try again) \n                  return setTimeout(function () {\n                    self._logHelper(\"Got Server Error. Retrying Request.\");\n\n                    return resolve();\n                  }, self.retry_delay * 1000);\n                }\n\n                self._logHelper(\"This should not be reached! Please report a bug!\");\n\n                return resolve();\n              });\n            });\n          }).then(function (results) {\n            return super_reject(\"Did not succeed after numerous attempts.\");\n          }).catch(function (err) {\n            return super_reject(err);\n          });\n        });\n      }\n    }, {\n      key: \"_method_helper\",\n      value: function _method_helper(endpoint, data, URL, METHOD) {\n        var self = this;\n        return new Promise(function (resolve, reject) {\n          self.get_token().then(function (token) {\n            return self._make_request(token, URL + endpoint, METHOD, data, 0, true, true);\n          }).then(function (results) {\n            // Returning [resultCode, body]\n            return resolve(results);\n          }).catch(function (err) {\n            return reject(err);\n          });\n        });\n      }\n    }, {\n      key: \"get\",\n      value: function get(endpoint, data) {\n        var METHOD = \"GET\";\n        var URL = REGULAR_REDDIT_URL;\n        return this._method_helper(endpoint, data, URL, METHOD);\n      }\n    }, {\n      key: \"post\",\n      value: function post(endpoint, data) {\n        var METHOD = \"POST\";\n        var URL = REGULAR_REDDIT_URL;\n        return this._method_helper(endpoint, data, URL, METHOD);\n      }\n    }, {\n      key: \"patch\",\n      value: function patch(endpoint, data) {\n        var METHOD = \"PATCH\";\n        var URL = REGULAR_REDDIT_URL;\n        return this._method_helper(endpoint, data, URL, METHOD);\n      }\n    }, {\n      key: \"put\",\n      value: function put(endpoint, data) {\n        var METHOD = \"PUT\";\n        var URL = REGULAR_REDDIT_URL;\n        return this._method_helper(endpoint, data, URL, METHOD);\n      }\n    }, {\n      key: \"del\",\n      value: function del(endpoint, data) {\n        var METHOD = \"DELETE\";\n        var URL = REGULAR_REDDIT_URL;\n        return this._method_helper(endpoint, data, URL, METHOD);\n      }\n    }]);\n\n    return API;\n  }();\n\n  return new API(options);\n};","map":null,"metadata":{},"sourceType":"script"}